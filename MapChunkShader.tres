[gd_resource type="Shader" format=3 uid="uid://co7puv05g5tp4"]

[resource]
code = "shader_type spatial;
render_mode blend_mix,depth_draw_opaque,cull_back,diffuse_burley,specular_schlick_ggx,depth_prepass_alpha;

uniform int tile_type_count;
uniform sampler2D noise_texture: filter_nearest;
uniform sampler2DArray textures_tiles: source_color,filter_nearest;
varying vec3 uv1_triplanar_pos;
varying vec3 uv1_power_normal;

vec3 debug(vec2 tile, vec4 texture_color) {
	if (mod(tile.x*32., 32.) < 1. || mod(tile.y*32., 32.) <= 1.) {
		return vec3(1.0,0.,0.);
	}
	return texture_color.rgb;
}

void vertex() {
	uv1_triplanar_pos = (MODEL_MATRIX * vec4(VERTEX, 1.0f)).xyz;
	// Normalisation des coordonnées triplanar pour des tuiles de 32 pixels
    uv1_triplanar_pos /= vec3(8192.0, 1.0, 8192.0);
}

vec4 triplanar_texture(sampler2D p_sampler,vec3 p_triplanar_pos) {
	vec4 samp = texture(p_sampler, p_triplanar_pos.xz );
	return samp;
}

void fragment() {
    vec2 tile = UV * 32.;
    
	float current_noise_value = floor(triplanar_texture(noise_texture, uv1_triplanar_pos ).r * float(tile_type_count));
    
    // Obtenez la texture correspondant à la valeur du tableau chunk_tiles
    vec4 texture_color = texture(textures_tiles, vec3(tile, current_noise_value));
	texture_color.rgb = debug(tile, texture_color);
	ALBEDO = texture_color.rgb;
	ALPHA = texture_color.a;
}
"
